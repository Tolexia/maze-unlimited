<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Unlimited</title>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    html, body, canvas 
    {
        height: 100lvh;
        width: 100lvw;
        overflow: hidden;
    }
</style>
<body>
    <canvas id="canvas">

    </canvas>
</body>
<script>
    var canvas = document.getElementById('canvas')

    const win_width = window.innerWidth
    const win_height = window.innerHeight

    canvas.width  = win_width
    canvas.height = win_height

    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;

    const edge_dist = 30
    const edge_thickness = 20
    const edge_min = edge_dist + edge_thickness
    const edge_largeness = Math.min( win_width ,  win_height )
    const margin_x = win_width - edge_largeness
    const margin_y = win_height - edge_largeness


    const cells = localStorage.getItem("cells") ? JSON.parse(localStorage.getItem("cells")) : []
    console.log("cells start" , localStorage.getItem("cells"))
    const cell_edges = ["top", "left", "bottom", "right"]
    const cell_size = 30

    const total_inside_largeness = edge_largeness - (edge_thickness * 2)
    const divide = total_inside_largeness / cell_size;
    const cell_count = parseInt(divide) - 2
    const total_padding = total_inside_largeness - (cell_count * cell_size)
    const cell_edge_tickness = total_padding / cell_count


    let current_x = localStorage.getItem("current_x") ? parseInt(localStorage.getItem("current_x")) : 0
    let current_y = localStorage.getItem("current_y") ? parseInt(localStorage.getItem("current_y")) : 0
    let current = cells.find(val => val.is_current === true)
    
    function drawEdge()
    {
        ctx.fillStyle = "black"
        ctx.fillRect(edge_dist + (margin_x / 2), edge_dist + (margin_y / 2), edge_largeness - (edge_dist* 2), edge_largeness-(edge_dist* 2));
        
        ctx.fillStyle = "white"
       
        ctx.fillRect(edge_min + (margin_x / 2), edge_min + (margin_y / 2), edge_largeness - (edge_min*2), edge_largeness-(edge_min*2));
    }

    function genMaze()
    {
        console.log("genMaze")
        let has_exit = false

        for(let x = 0; x < cell_count ; x++)
        {
            for(let y = 0; y < cell_count ; y++)
            {
               
                // Determine Edges

                const edges = []

                if(x == 0)
                    edges.push("left")
                
                
                if(y == 0)
                    edges.push("top")
                
                if(x == (cell_count - 1))
                    edges.push("right")
                
                if(y == (cell_count - 1))
                    edges.push("bottom")
                
                const prev_x = cells[x-1]
                const prev_y = cells[y-1]


                for(let edge_pos = 0; edge_pos < cell_edges.length ; edge_pos++)
                {
                    const current_edge = cell_edges[edge_pos]

                    if(edges.includes(current_edge))
                        continue;

                    
                    const random = Math.random()

                    let add_edge_threshold = 0
                    switch(edges.length)
                    {
                        case 0:
                            add_edge_threshold = 0.5
                            break;
                        case 1:
                            add_edge_threshold = 0.25
                            break;
                        case 2:
                            add_edge_threshold = 0.025
                            break;
                        default:
                            break;
                    }

                    if(prev_x)
                    {
                        if(current_edge == "left" || current_edge == "right")
                        {
                            if(prev_x.edges.includes("left") || prev_x.edges.includes("right"))
                            {
                                add_edge_threshold /= 3
                            }
                        }
                    }
                        
                    if(random < add_edge_threshold)
                        edges.push(current_edge)
                }

                // Determine Exit
                let is_exit = false
                if(
                    !has_exit && 
                    x  >= (cell_count / 2) - 2 && 
                    x  <= (cell_count / 2) + 2 && 
                    y  >= (cell_count / 2) - 2 && 
                    y  <= (cell_count / 2) + 2 &&
                    Math.random() >= 0.4
                )
                {
                    is_exit = has_exit = true
                }

                // Determine if current cell
                const is_current = (x == 0 && y == 0)

                cells.push({
                    x,
                    y,
                    edges,
                    is_exit,
                    is_current,
                    has_past_by: false
                })
            }
        }

        localStorage.setItem("cells", JSON.stringify(cells))
    }

    function drawMaze()
    {
        const initial_x = edge_min + (margin_x / 2)
        const initial_y = edge_min + (margin_y / 2)
        ctx.clearRect(initial_x,initial_y,total_inside_largeness-total_padding,total_inside_largeness-total_padding)

        for(let x = 0; x < cell_count ; x++)
        {
            for(let y = 0; y < cell_count ; y++)
            {
                const cell = cells.find(val => val.x == x && val.y == y)

                let x_pos = initial_x + (x * cell_size) 
                let y_pos = initial_y + (y * cell_size)

                x_pos += cell_edge_tickness
                y_pos += cell_edge_tickness
                
                // Draw cell with edges
                for(let edge_pos = 0; edge_pos < cell_edges.length ; edge_pos++)
                {
                    const current_edge = cell_edges[edge_pos]

                    if(!cell.edges.includes(current_edge))
                        continue;

                    let x_edge_min, edge_width, y_edge_min, edge_height

                    ctx.fillStyle = "black"

                    const half_edge = cell_edge_tickness / 2

                    switch(current_edge)
                    {
                        case "top":
                            x_edge_min = x_pos
                            y_edge_min = y_pos
                            edge_width = cell_size
                            edge_height = cell_edge_tickness
                            break;
                        case "right":
                            x_edge_min = x_pos + cell_size
                            y_edge_min = y_pos
                            edge_width = cell_edge_tickness
                            edge_height = cell_size
                            break;
                        case "bottom":
                            x_edge_min = x_pos
                            y_edge_min = y_pos + cell_size
                            edge_width = cell_size
                            edge_height = cell_edge_tickness
                            break;
                        case "left":
                            x_edge_min = x_pos
                            y_edge_min = y_pos
                            edge_width = cell_edge_tickness
                            edge_height = cell_size
                            break;
                        default:
                            break;
                    }

                    ctx.fillRect(x_edge_min, y_edge_min, edge_width, edge_height);   
                }

                // Draw inner cell
                if(cell.is_current)
                    ctx.fillStyle = "black"
                else if(cell.is_exit)
                    ctx.fillStyle = "red"
                else if(cell.has_past_by)
                    ctx.fillStyle = "#FFFFFF55"
                else
                    ctx.fillStyle = "transparent"

                ctx.fillRect(x_pos, y_pos, cell_size, cell_size);

            }
        }
    }

    function init()
    {
        drawEdge()

        if(cells.length == 0)
            genMaze()

        current = cells.find(val => val.is_current === true)
        drawMaze()
    }

    function up()
    {
        const dest = cells.find(val => val.y == current_y-1 && val.x == current_x)
        if(current_y > 0 && !current.edges.includes("top") && !dest.edges.includes("bottom")) current_y -= 1
        localStorage.setItem("current_y", current_y)
        updateCurrent()
    }
    function left()
    {
        const dest = cells.find(val => val.y == current_y && val.x == current_x-1)
        if(current_x > 0 && !current.edges.includes("left") && !dest.edges.includes("right")) current_x -= 1
        localStorage.setItem("current_x", current_x)
        updateCurrent()
    }
    function down()
    {
        const dest = cells.find(val => val.y == current_y+1 && val.x == current_x)
        if(current_y < cell_count - 1 && !current.edges.includes("bottom") && !dest.edges.includes("top")) current_y += 1
        localStorage.setItem("current_y", current_y)
        updateCurrent()
    }
    function right()
    {
        const dest = cells.find(val => val.y == current_y && val.x == current_x+1)
        if(current_x < cell_count - 1 && !current.edges.includes("right") && !dest.edges.includes("left")) current_x += 1
        localStorage.setItem("current_x", current_x)
        updateCurrent()
    }
    let animating = false
    document.body.addEventListener('keydown', e => {
    
        if(e.key == "ArrowUp") {
            up()
        }
        if(e.key == "ArrowLeft") {
            left()
        }
        if(e.key == "ArrowRight") {
            right()
        }
        if(e.key == "ArrowDown") {
            down()
        }
    })

    function updateCurrent()
    {
        current.is_current = false
        current.has_past_by = true

        const new_current = cells.find(val => val.x == current_x && val.y == current_y)
        if(new_current)
        {
            if(new_current.is_exit)  return has_won()

            new_current.is_current = true
            current = new_current
        } 
        localStorage.setItem("cells", JSON.stringify(cells))
        drawMaze()
    }

    function has_won()
    {
        localStorage.clear()
        alert("You Win !")
        window.location.reload()
        
    }

    init()
    /*function draw() 
    {

        requestAnimationFrame(draw)
    }*/
</script>
</html>